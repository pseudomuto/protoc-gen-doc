[
    {
        "scalar_value_proto_type": "double",
        "scalar_value_notes": "",
        "scalar_value_cpp_type": "double",
        "scalar_value_java_type": "double",
        "scalar_value_python_type": "float"
    },
    {
        "scalar_value_proto_type": "float",
        "scalar_value_notes": "",
        "scalar_value_cpp_type": "float",
        "scalar_value_java_type": "float",
        "scalar_value_python_type": "float"
    },
    {
        "scalar_value_proto_type": "int32",
        "scalar_value_notes": "Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead.",
        "scalar_value_cpp_type": "int32",
        "scalar_value_java_type": "int",
        "scalar_value_python_type": "int"
    },
    {
        "scalar_value_proto_type": "int64",
        "scalar_value_notes": "Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead.",
        "scalar_value_cpp_type": "int64",
        "scalar_value_java_type": "long",
        "scalar_value_python_type": "int/long"
    },
    {
        "scalar_value_proto_type": "uint32",
        "scalar_value_notes": "Uses variable-length encoding.",
        "scalar_value_cpp_type": "uint32",
        "scalar_value_java_type": "int",
        "scalar_value_python_type": "int/long"
    },
    {
        "scalar_value_proto_type": "uint64",
        "scalar_value_notes": "Uses variable-length encoding.",
        "scalar_value_cpp_type": "uint64",
        "scalar_value_java_type": "long",
        "scalar_value_python_type": "int/long"
    },
    {
        "scalar_value_proto_type": "sint32",
        "scalar_value_notes": "Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.",
        "scalar_value_cpp_type": "int32",
        "scalar_value_java_type": "int",
        "scalar_value_python_type": "int"
    },
    {
        "scalar_value_proto_type": "sint64",
        "scalar_value_notes": "Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.",
        "scalar_value_cpp_type": "int64",
        "scalar_value_java_type": "long",
        "scalar_value_python_type": "int/long"
    },
    {
        "scalar_value_proto_type": "fixed32",
        "scalar_value_notes": "Always four bytes. More efficient than uint32 if values are often greater than 2^28.",
        "scalar_value_cpp_type": "uint32",
        "scalar_value_java_type": "int",
        "scalar_value_python_type": "int"
    },
    {
        "scalar_value_proto_type": "fixed64",
        "scalar_value_notes": "Always eight bytes. More efficient than uint64 if values are often greater than 2^56.",
        "scalar_value_cpp_type": "uint64",
        "scalar_value_java_type": "long",
        "scalar_value_python_type": "int/long"
    },
    {
        "scalar_value_proto_type": "sfixed32",
        "scalar_value_notes": "Always four bytes.",
        "scalar_value_cpp_type": "int32",
        "scalar_value_java_type": "int",
        "scalar_value_python_type": "int"
    },
    {
        "scalar_value_proto_type": "sfixed64",
        "scalar_value_notes": "Always eight bytes.",
        "scalar_value_cpp_type": "int64",
        "scalar_value_java_type": "long",
        "scalar_value_python_type": "int/long"
    },
    {
        "scalar_value_proto_type": "bool",
        "scalar_value_notes": "",
        "scalar_value_cpp_type": "bool",
        "scalar_value_java_type": "boolean",
        "scalar_value_python_type": "boolean"
    },
    {
        "scalar_value_proto_type": "string",
        "scalar_value_notes": "A string must always contain UTF-8 encoded or 7-bit ASCII text.",
        "scalar_value_cpp_type": "string",
        "scalar_value_java_type": "String",
        "scalar_value_python_type": "str/unicode"
    },
    {
        "scalar_value_proto_type": "bytes",
        "scalar_value_notes": "May contain any arbitrary sequence of bytes.",
        "scalar_value_cpp_type": "string",
        "scalar_value_java_type": "ByteString",
        "scalar_value_python_type": "str"
    }
]